package IC.Parser;

import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.Symbol;
import IC.*;
import IC.AST.*;
import IC.Parser.*;
parser code {:
	/**
	 * Causes the parsr to print every token it reads. useful for debugging
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public int getLine() {
		return lexer.getLine();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + Utils.tokenIDToString(tok.getId()));
	}
:};
// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + Utils.tokenIDToString(t.getId()));
	return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program program;
non terminal ICClass class;
non terminal List<ICClass> class_list;
non terminal Field	field;
non terminal List<Field> fields;
non terminal List<Field> fieldsinrow;
non terminal Method	method;
non terminal Type	type;
non terminal Formal formal;
non terminal List<Formal> formals;
non terminal Statement statement;
non terminal StatementsBlock stmt_list;
non terminal If ifStatement;
non terminal Expression expr;
non terminal List<Expression> exprlist, actualParams, properActualParams;
non terminal Type returnType;      
non terminal ClassContents classcontents;
non terminal Location location;
non terminal Call call;
non terminal Literal literal;
non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;


terminal Integer INTEGER;
terminal String  QUOTE;
terminal String ID, CLASS_ID;
terminal Boolean FALSE, TRUE;
terminal LENGTH, NEQUAL, EQUAL, RP, SEMI, DOT, LP, PLUS, MINUS, MULTIPLY, DIVIDE, GT, GTE, LT, LTE, LB, LCBR, RCBR, RB, LNEG, LAND, LOR, MOD, COMMA,
		 IF, ASSIGN, BREAK, CLASS, CONTINUE, EXTENDS, ELSE, NEW, RETURN, THIS, VOID, WHILE, STATIC;
terminal INT, STRING, BOOLEAN, UMINUS;
terminal NULL;


//////////////////////////
// Precedence declarations

precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GTE, GT, LT, LTE;
precedence left MINUS, PLUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right UMINUS, LNEG; 
precedence left DOT, LP, RP, LB, RB;

//////////////
// The grammar

program ::= class_list:cl
      {: RESULT = new Program(cl); :}
;

class_list ::= class:c {:
      	RESULT = new ArrayList<ICClass>(); RESULT.add(c);
      :}
      	| class_list:cl class:c
      {: cl.add(c); RESULT = cl; :}
;

class ::= CLASS CLASS_ID:name EXTENDS CLASS_ID:superclassico LCBR classcontents:cc RCBR {: 
		RESULT = new ICClass(parser.getLine(),name,superclassico, cc.getFields(), cc.getMethods());	
	:} | 
	CLASS CLASS_ID:name LCBR classcontents:cc RCBR {: 
		RESULT = new ICClass(parser.getLine(),name, cc.getFields(), cc.getMethods());	
	:}
;
	

classcontents ::= 
	fields:f {:
		ClassContents cc = new ClassContents(parser.getLine());
		List<Field> fields = cc.getFields();
		fields.addAll(f);
		cc.setFields(fields);
		RESULT = cc;
	 :} |
	 method:m {:
		ClassContents cc = new ClassContents(parser.getLine());
		List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :} | 
	 classcontents:cc fields:f {:
	 	List<Field> fields = cc.getFields();
	 	fields.addAll(f);
	 	cc.setFields(fields);
		RESULT = cc;
	 :} | classcontents:cc method:m {:
	 	List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :}
;


fields ::= fieldsinrow:row SEMI {: RESULT = row; :}
; 

fieldsinrow ::= 
		field:f {:
			ArrayList<Field> list = new ArrayList<Field>();
			list.add(f);
			RESULT = list; :} |
		fieldsinrow:row COMMA ID:id {:
			Field field = new Field(row.get(0).getType(), id);
			row.add(field);
			RESULT = row;
		:}
;
		
field ::=
	      type:t ID:id {:
   		  	RESULT = new Field(t,id); :}
;
			 	 	 
method ::=  STATIC type:t ID:f LP formals:formals RP stmt_list:st  {:
				RESULT = new StaticMethod(t,f,formals, st.getStatements()); :} |
			type:t ID:f LP formals:formals RP stmt_list:st  {:
				RESULT = new VirtualMethod(t,f,formals, st.getStatements()); :} |
			STATIC type:t ID:f LP RP stmt_list:st  {:
				RESULT = new StaticMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			type:t ID:f LP RP stmt_list:st  {:
				RESULT = new VirtualMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			STATIC VOID ID:f LP formals:formals RP stmt_list:st  {:
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			VOID ID:f LP formals:formals RP stmt_list:st  {:
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			STATIC VOID ID:f LP RP stmt_list:st  {:
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :} |
			VOID ID:f LP RP stmt_list:st  {:
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :}
;

formal ::= type:t ID:id {: RESULT = new Formal(t,id); :}
;

formals ::= formal:fo {:
			ArrayList<Formal> flist = new ArrayList<Formal>();
			flist.add(fo); RESULT = flist; :}
			|
			formals:flist COMMA formal:fo {:
			flist.add(fo); RESULT = flist; :}
;
				 
		
	
type ::= INT {:
		RESULT = new PrimitiveType(parser.getLine(), DataTypes.INT);:} | 
	    STRING {: RESULT = new PrimitiveType(parser.getLine(), DataTypes.STRING);:} | 
	    BOOLEAN{: RESULT = new PrimitiveType(parser.getLine(), DataTypes.BOOLEAN);:} | 
	    CLASS_ID:c {: RESULT = new UserType(parser.getLine(), c); :} |
		type:t LB RB {:
			t.incrementDimension();
			RESULT = t;
		:}
;

expr ::=	
			expr:e1 PLUS expr:e2 {: 
				RESULT = new MathBinaryOp(e1,BinaryOps.PLUS,e2); :} |
			expr:e1 MINUS expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.MINUS,e2); :} |
			expr:e1 MULTIPLY expr:e2 {: 
				RESULT = new MathBinaryOp(e1,BinaryOps.MULTIPLY,e2); :} |
			expr:e1 DIVIDE expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.DIVIDE,e2); :} |
			expr:e1 MOD expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.MOD,e2); :} |
			expr:e1 EQUAL expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.EQUAL,e2); :} |
			expr:e1 NEQUAL expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.NEQUAL,e2); :} |
			expr:e1 GT expr:e2 {: 
				RESULT = new MathBinaryOp(e1,BinaryOps.GT,e2); :} |
			expr:e1 GTE expr:e2 {: 
				RESULT = new MathBinaryOp(e1,BinaryOps.GTE,e2); :} |
			expr:e1 LT expr:e2 {:
				RESULT = new MathBinaryOp(e1,BinaryOps.LT,e2); :} |
			expr:e1 LTE expr:e2 {:
				new MathBinaryOp(e1,BinaryOps.LTE,e2); :} |
			expr:e1 LAND expr:e2 {: 
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LAND,e2); :} |
			expr:e1 LOR expr:e2 {: 
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LOR,e2); :} |
			LNEG expr:e1 {: 
				RESULT = new LogicalUnaryOp(UnaryOps.LNEG,e1); :} |
			MINUS expr:e1  {:
				RESULT = new MathUnaryOp(UnaryOps.UMINUS,e1); :} %prec UMINUS |
			ID:f LP exprlist:args RP {:
				RESULT = new VirtualCall(parser.getLine(),f,args); :} |
			expr:arr DOT LENGTH {:
				RESULT = new Length(arr); :} |
			QUOTE:str {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.STRING,str); :} |
			LP expr:e1 RP {: RESULT = new ExpressionBlock(e1); :} |
			NEW:id CLASS_ID:name LP RP SEMI {: RESULT = new NewClass(parser.getLine(),name); :} |
			NEW:id type:name LB expr:size RB SEMI {: RESULT = new NewArray(name,size); :} |
			location:e {: RESULT = e;:} | 
			call:e {:RESULT = e;:} |
			THIS {:
				RESULT = new This(parser.getLine());:}  |
			INTEGER:x {:
				RESULT = new Literal(parser.getLine(), LiteralTypes.INTEGER, x);:} |
			TRUE:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE);:}  |
			FALSE:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.FALSE);:}  |
			NULL:x {:
				RESULT = new Literal(parser.getLine(),LiteralTypes.NULL);:} 
;

exprlist ::= expr:e {:
			List<Expression> list = new ArrayList<Expression>();
			list.add(e);
			RESULT = list; :} | 
 			 exprlist:list COMMA expr:e{:
 			 	list.add(e);
 			 	RESULT = list;
 			 :} 
;

stmt_list ::= statement:st {:
		List<Statement> temp = new ArrayList<Statement>(); temp.add(st); 
		RESULT = new StatementsBlock(parser.getLine(),temp);
	:} 	|
		stmt_list:s1 statement:s {:
		List<Statement> temp = s1.getStatements();
		temp.add(s);
		RESULT = new StatementsBlock(parser.getLine(), temp);
	:}
;

statement ::= 	IF LP expr:e RP statement:s ELSE statement:es {: 
					RESULT = new If(e,s,es);:}  |
				IF LP expr:e RP statement:s {:
					RESULT = new If(e,s);:} |
				WHILE LP expr:e RP statement:s {: 
					RESULT = new While(e,s);:} |
				BREAK:b SEMI {:
					RESULT = new Break(parser.getLine()); :} |
				CONTINUE SEMI {:
					RESULT = new Continue(parser.getLine()); :} |
				RETURN expr:e SEMI {:
					RESULT = new Return(parser.getLine(),e); :} |
				RETURN:e SEMI {:
					RESULT = new Return(parser.getLine()); :} |
				ID:f LP exprlist:args RP SEMI {: 
					RESULT = new CallStatement(new VirtualCall(parser.getLine(),f,args)); :} |
				type:t ID:id ASSIGN expr:e SEMI {: 
					Location loc = new VariableLocation(parser.getLine(),id);
					RESULT = new Assignment(loc,e); :}  |
				type:t ID:id SEMI {:
					RESULT = new LocalVariable(t,id); :} |
				call:c SEMI {:
					RESULT = new CallStatement(c);
				:} |
				location:loc ASSIGN expr:e SEMI {:
					RESULT = new Assignment(loc,e);
				:} 
;

location ::=	ID:id {:
					RESULT = new VariableLocation(parser.getLine(), id);:} |
			  	expr:e DOT ID:id {:
			  		RESULT = new VariableLocation(parser.getLine(), e, id); :} |
			  	expr:arr LB expr:index RB {:
			  		RESULT = new ArrayLocation(arr,index); :}
;

call ::= 	staticCall:c {: 
				RESULT = c;
			:} |
			virtualCall:c {: 
				RESULT = c;
			:} ;

staticCall ::= CLASS_ID:c DOT ID:f LP exprlist:args RP {:
				RESULT = new StaticCall(parser.getLine(),c, f,args);  :}
;

virtualCall ::= expr:e DOT ID:f LP exprlist:args RP {:
					RESULT = new VirtualCall(parser.getLine(),e,f,args);:} |
				ID:name LP actualParams:args RP {:
					RESULT = new VirtualCall(parser.getLine(),name,args);:}
;
			  	