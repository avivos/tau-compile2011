package IC.Parser;

import java.util.ArrayList;
import java.util.List;

import java_cup.runtime.*;
import IC.*;
import IC.AST.*;
import IC.Parser.*;

parser code {:


	/**
	 * Causes the parser to print every token it reads. useful for debugging
	 */
	public boolean printTokens;
	
	private Lexer lexer;

	public Parser(Lexer lexer) {
		super(lexer);
		this.lexer = lexer;
	}
	
	public void log(String msg) {
			System.out.println(getLine() + " : " + msg);
	}
	public int getLine() {
		return lexer.getLine();
	}
	
	public void syntax_error(Symbol s) {
		Token tok = (Token) s;
		System.out.println("Line " + tok.getLine()+": Syntax error; unexpected " + Utils.tokenIDToString(tok.getId()));
	}
:};
// This is just for debugging
scan with {:
	Token t = lexer.next_token();
	if (printTokens)
		System.out.println(t.getLine() + ":" + Utils.tokenIDToString(t.getId()));
	return t; 
:};

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

non terminal Program program;
non terminal ICClass class;
non terminal List<ICClass> class_list;
non terminal Field	field;
non terminal List<Field> fields;
non terminal List<Field> fieldsinrow;
non terminal Method	method;
non terminal Type	type;
non terminal Formal formal;
non terminal List<Formal> formals;
non terminal Statement statement;
non terminal StatementsBlock stmt_list;
non terminal If ifStatement;
non terminal Expression expr;
non terminal List<Expression> exprlist, actualParams, properActualParams;
non terminal Type returnType;      
non terminal ClassContents classcontents;
non terminal Location location;
non terminal Call call;
non terminal Literal literal;
non terminal StaticCall staticCall;
non terminal VirtualCall virtualCall;


terminal Integer INTEGER;
terminal String  QUOTE;
terminal String ID, CLASS_ID;
terminal Boolean FALSE, TRUE;
terminal LENGTH, NEQUAL, EQUAL, RP, SEMI, DOT, LP, PLUS, MINUS, MULTIPLY, DIVIDE, GT, GTE, LT, LTE, LB, LCBR, RCBR, RB, LNEG, LAND, LOR, MOD, COMMA,
		 IF, ASSIGN, BREAK, CLASS, CONTINUE, EXTENDS, ELSE, NEW, RETURN, THIS, VOID, WHILE, STATIC;
terminal INT, STRING, BOOLEAN, UMINUS;
terminal NULL;


//////////////////////////
// Precedence declarations

precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GTE, GT, LT, LTE;
precedence left MINUS, PLUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right UMINUS, LNEG; 
precedence left DOT, LP, RP, LB, RB;

//////////////
// The grammar

program ::= class_list:cl {:
	parser.log("program ::= class_list");
	RESULT = new Program(cl); :}
;

class_list ::= class:c {:
		parser.log("class_list ::= class");
      	RESULT = new ArrayList<ICClass>(); RESULT.add(c);
      :}
      	| class_list:cl class:c {: 
      		parser.log("class_list ::= class_list class");
      		cl.add(c); RESULT = cl; :}
;

class ::= CLASS CLASS_ID:name EXTENDS CLASS_ID:superclassico LCBR classcontents:cc RCBR {: 
	parser.log("class::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR classcontents RCBR");
	RESULT = new ICClass(parser.getLine(),name,superclassico, cc.getFields(), cc.getMethods());	
	:} | 
	CLASS CLASS_ID:name LCBR classcontents:cc RCBR {: 
		parser.log("class::= CLASS CLASS_ID  CLASS_ID LCBR classcontents RCBR");
		RESULT = new ICClass(parser.getLine(),name, cc.getFields(), cc.getMethods());	
	:}
;
	

classcontents ::= 
	fields:f {:
		parser.log("classcontents ::= fields");
		ClassContents cc = new ClassContents(parser.getLine());
		List<Field> fields = cc.getFields();
		fields.addAll(f);
		cc.setFields(fields);
		RESULT = cc;
	 :} |
	 method:m {:
	 	parser.log("classcontents ::= method");
		ClassContents cc = new ClassContents(parser.getLine());
		List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :} | 
	 classcontents:cc fields:f {:
	 	parser.log("classcontents ::= classcontents fields");
	 	List<Field> fields = cc.getFields();
	 	fields.addAll(f);
	 	cc.setFields(fields);
		RESULT = cc;
	 :} | classcontents:cc method:m {:
	 	parser.log("classcontents ::= classcontents method");
	 	List<Method> methods = cc.getMethods();
		methods.add(m);
		cc.setMethods(methods);
		RESULT = cc;
	 :}
;


fields ::= fieldsinrow:row SEMI {:
	parser.log("fields ::= fieldsinrow SEMI");
	RESULT = row; :}
; 

fieldsinrow ::= 
		field:f {:
			parser.log("fieldsinrow ::= field");
			ArrayList<Field> list = new ArrayList<Field>();
			list.add(f);
			RESULT = list; :} |
		fieldsinrow:row COMMA ID:id {:
			parser.log("fieldsinrow ::= fieldsinrow COMMA ID");
			Field field = new Field(row.get(0).getType(), id);
			row.add(field);
			RESULT = row;
		:}
;
		
field ::=
	      type:t ID:id {:
	      	parser.log("field ::= type ID");
   		  	RESULT = new Field(t,id); :}
;
			 	 	 
method ::=  STATIC type:t ID:f LP formals:formals RP stmt_list:st {:
				parser.log("method ::= STATIC type ID LP formals RP stmt_list");
				RESULT = new StaticMethod(t,f,formals, st.getStatements()); :} |
			type:t ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= type ID LP formals RP stmt_list");
				RESULT = new VirtualMethod(t,f,formals, st.getStatements()); :} |
			STATIC type:t ID:f LP RP stmt_list:st  {:
				parser.log("method ::= STATIC type ID LP RP stmt_list");
				RESULT = new StaticMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			type:t ID:f LP RP stmt_list:st  {:
				parser.log("method ::= type ID LP RP stmt_list");
				RESULT = new VirtualMethod(t,f,new ArrayList<Formal>(), st.getStatements()); :} |
			STATIC VOID ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= STATIC VOID ID LP formals RP stmt_list");
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			VOID ID:f LP formals:formals RP stmt_list:st  {:
				parser.log("method ::= VOID ID LP formals RP stmt_list");
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,formals, st.getStatements()); :} |
			STATIC VOID ID:f LP RP stmt_list:st  {:
				parser.log("method ::= STATIC VOID ID LP RP stmt_list");
				RESULT = new StaticMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :} |
			VOID ID:f LP RP stmt_list:st  {:
				parser.log("method ::= VOID ID LP RP stmt_list");
				RESULT = new VirtualMethod(new PrimitiveType(parser.getLine(), DataTypes.VOID),f,new ArrayList<Formal>(), st.getStatements()); :}
;

formal ::= type:t ID:id {:
	parser.log("formal ::= type ID");
	RESULT = new Formal(t,id); :}
;

formals ::= formal:fo {:
				parser.log("formals ::= formal");
				ArrayList<Formal> flist = new ArrayList<Formal>();
				flist.add(fo); RESULT = flist; :} |
			formals:flist COMMA formal:fo {:
				parser.log("formals ::= flist COMMA formal");
				flist.add(fo); RESULT = flist; :}
;
				 
		
	
type ::= INT {:
			parser.log("type ::= INT");
			RESULT = new PrimitiveType(parser.getLine(), DataTypes.INT);:} | 
	    STRING {:
	    	parser.log("type ::= STRING");
	    	RESULT = new PrimitiveType(parser.getLine(), DataTypes.STRING);:} | 
	    BOOLEAN{:
	    	parser.log("type ::= BOOLEAN");	
	    	RESULT = new PrimitiveType(parser.getLine(), DataTypes.BOOLEAN);:} | 
	    CLASS_ID:c {:
	    	parser.log("type ::= CLASS_ID");
	    	RESULT = new UserType(parser.getLine(), c); :} |
		type:t LB RB {:
			parser.log("type ::= type LB RB");
			t.incrementDimension();
			RESULT = t;
		:}
;

expr ::=	
			expr:e1 PLUS expr:e2 {: 
				parser.log("expr ::= expr PLUS expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.PLUS,e2); :} |
			expr:e1 MINUS expr:e2 {:
				parser.log("expr ::= expr MINUS expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MINUS,e2); :} |
			expr:e1 MULTIPLY expr:e2 {: 
				parser.log("expr ::= expr MULTIPLY expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MULTIPLY,e2); :} |
			expr:e1 DIVIDE expr:e2 {:
				parser.log("expr ::= expr DIVIDE expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.DIVIDE,e2); :} |
			expr:e1 MOD expr:e2 {:
				parser.log("expr ::= expr MOD expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.MOD,e2); :} |
			expr:e1 EQUAL expr:e2 {:
				parser.log("expr ::= expr EQUAL expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.EQUAL,e2); :} |
			expr:e1 NEQUAL expr:e2 {:
				parser.log("expr ::= expr NEQUAL expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.NEQUAL,e2); :} |
			expr:e1 GT expr:e2 {: 
				parser.log("expr ::= expr GT expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.GT,e2); :} |
			expr:e1 GTE expr:e2 {: 
				parser.log("expr ::= expr GTE expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.GTE,e2); :} |
			expr:e1 LT expr:e2 {:
				parser.log("expr ::= expr LT expr");
				RESULT = new MathBinaryOp(e1,BinaryOps.LT,e2); :} |
			expr:e1 LTE expr:e2 {:
				parser.log("expr ::= expr LTE expr");
				new MathBinaryOp(e1,BinaryOps.LTE,e2); :} |
			expr:e1 LAND expr:e2 {: 
				parser.log("expr ::= expr LAND expr");
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LAND,e2); :} |
			expr:e1 LOR expr:e2 {: 
				parser.log("expr ::= expr LOR expr");
				RESULT = new LogicalBinaryOp(e1,BinaryOps.LOR,e2); :} |
			LNEG expr:e1 {: 
				parser.log("expr ::= LNEG expr");
				RESULT = new LogicalUnaryOp(UnaryOps.LNEG,e1); :} |
			MINUS expr:e1  {:
				parser.log("expr ::= MINUS expr");
				RESULT = new MathUnaryOp(UnaryOps.UMINUS,e1); :} %prec UMINUS |
			ID:f LP exprlist:args RP {:
				parser.log("expr ::= ID LP exprlist RP");
				RESULT = new VirtualCall(parser.getLine(),f,args); :} |
			expr:arr DOT LENGTH {:
				parser.log("expr ::= expr DOT LENGTH");
				RESULT = new Length(arr); :} |
			QUOTE:str {:
				parser.log("expr ::= QUOTE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.STRING,str); :} |
			LP expr:e1 RP {:
				 parser.log("expr ::= LP expr RP");
				 RESULT = new ExpressionBlock(e1); :} |
			NEW:id CLASS_ID:name LP RP SEMI {:
				parser.log("expr ::= NEW CLASS_ID LP RP SEMI");
				RESULT = new NewClass(parser.getLine(),name); :} |
			NEW:id type:name LB expr:size RB SEMI {:
				parser.log("expr ::= NEW type LB exp RB SEMI");
				RESULT = new NewArray(name,size); :} |
			location:e {:
				parser.log("expr ::= location");
				RESULT = e;:} | 
			call:e {:
				parser.log("expr ::= call");
				RESULT = e;:} |
			THIS {:
				parser.log("expr ::= THIS");
				RESULT = new This(parser.getLine());:}  |
			INTEGER:x {:
				parser.log("expr ::= INTEGER");
				RESULT = new Literal(parser.getLine(), LiteralTypes.INTEGER, x);:} |
			TRUE:x {:
				parser.log("expr ::= TRUE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.TRUE);:}  |
			FALSE:x {:
				parser.log("expr ::= FALSE");
				RESULT = new Literal(parser.getLine(),LiteralTypes.FALSE);:}  |
			NULL:x {:
				parser.log("expr ::= NULL");
				RESULT = new Literal(parser.getLine(),LiteralTypes.NULL);:} 
;

exprlist ::= expr:e {:
				parser.log("exprlist ::= expr");
				List<Expression> list = new ArrayList<Expression>();
				list.add(e);
				RESULT = list; :} | 
 			exprlist:list COMMA expr:e {:
 			 	parser.log("exprlist ::= exprlist COMMA expr");
 			 	list.add(e);
 			 	RESULT = list;:} 
;

stmt_list ::= statement:st {:
		parser.log("stmt_list ::= statement");
		List<Statement> temp = new ArrayList<Statement>(); temp.add(st); 
		RESULT = new StatementsBlock(parser.getLine(),temp);
	:} 	|
		stmt_list:s1 statement:s {:
			parser.log("stmt_list ::= stmt_list statement");
			List<Statement> temp = s1.getStatements();
			temp.add(s);
			RESULT = new StatementsBlock(parser.getLine(), temp); :}
;

statement ::= 	IF LP expr:e RP statement:s ELSE statement:es {: 
					parser.log("statement ::= IF LP expr RP statement ELSE statement");
					RESULT = new If(e,s,es);:}  |
				IF LP expr:e RP statement:s {:
					parser.log("statement ::= IF LP expr RP statement");
					RESULT = new If(e,s);:} |
				WHILE LP expr:e RP statement:s {: 
					parser.log("statement ::= WHILE LP expr RP statement");
					RESULT = new While(e,s);:} |
				BREAK:b SEMI {:
					parser.log("statement ::= BREAK SEMI");
					RESULT = new Break(parser.getLine()); :} |
				CONTINUE SEMI {:
					parser.log("statement ::= CONTINUE SEMI");
					RESULT = new Continue(parser.getLine()); :} |
				RETURN expr:e SEMI {:
					parser.log("statement ::= RETURN expr SEMI");
					RESULT = new Return(parser.getLine(),e); :} |
				RETURN SEMI {:
					parser.log("statement ::= RETURN SEMI");
					RESULT = new Return(parser.getLine()); :} |
				ID:f LP exprlist:args RP SEMI {: 
					parser.log("statement ::= ID LP exprlist RP SEMI");
					RESULT = new CallStatement(new VirtualCall(parser.getLine(),f,args)); :} |
				type:t ID:id ASSIGN expr:e SEMI {: 
					parser.log("statement ::= type ID ASSIGN expr SEMI");
					Location loc = new VariableLocation(parser.getLine(),id);
					RESULT = new Assignment(loc,e); :}  |
				type:t ID:id SEMI {:
					parser.log("statement ::= type ID SEMI");
					RESULT = new LocalVariable(t,id); :} |
				call:c SEMI {:
					parser.log("statement ::= call SEMI");
					RESULT = new CallStatement(c);
				:} |
				location:loc ASSIGN expr:e SEMI {:
					parser.log("statement ::= location ASSIGN expr SEMI");
					RESULT = new Assignment(loc,e);
				:}  |
				LCBR stmt_list:st RCBR {:
					parser.log("statement ::= LCBR stmt_list RCBR");
					RESULT = st;
				:}
;

location ::=	ID:id {:
					parser.log("location ::= ID");
					RESULT = new VariableLocation(parser.getLine(), id);:} |
			  	expr:e DOT ID:id {:
			  		parser.log("location ::= expr DOT ID");
			  		RESULT = new VariableLocation(parser.getLine(), e, id); :} |
			  	expr:arr LB expr:index RB {:
			  		parser.log("location ::= expr LB expr RB");
			  		RESULT = new ArrayLocation(arr,index); :}
;

call ::= 	staticCall:c {: 
				parser.log("call ::= staticCall");
				RESULT = c;
			:} |
			virtualCall:c {: 
				parser.log("call ::= virtualCall");
				RESULT = c;
			:} ;

staticCall ::= CLASS_ID:c DOT ID:f LP exprlist:args RP {:
				parser.log("staticCall ::= CLASS_ID DOT ID LP exprlist RP");
				RESULT = new StaticCall(parser.getLine(),c, f,args);  :}
;

virtualCall ::= expr:e DOT ID:f LP exprlist:args RP {:
					parser.log("virtualCall ::= expr DOT ID LP exprlist RP");
					RESULT = new VirtualCall(parser.getLine(),e,f,args);:} |
				ID:name LP actualParams:args RP {:
					parser.log("virtualCall ::= ID LP actualParams:args RP");
					RESULT = new VirtualCall(parser.getLine(),name,args);:}
;
			  	