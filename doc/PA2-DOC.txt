         CLASS HIERARCHY
        -----------------
src:
	package IC:
		    Compiler.java
	
	package IC.AST:
	 		
	 		ASTNode.java
	 		ASTNode extending classes
	 		
	 		ClassContents.java
			
	package IC.Parser:
			
			Lexer.java
			LexicalError.java
			sym.java
			Token.java
			Utils.java
			IC.lex 
			SyntaxError.java
			IC.cup
			Parser.java
			sym.java 
			Library.cup
			LibraryParser.java
			
			
         DESCRIPTION OF MAJOR CLASSES
         -----------------------------
IC
===
CLASS Compiler:
	The Compiler is the class where the main is.
	It recieves command line arguments and works accordingly.
	It parses the input .ic file according to the parser which is generated from IC.CUP.
	If needed it parses a .sig file.
	If requires it prints the output AST's by using the PrettyPrinter visitor. 

IC.Parser
=========
CLASS LexicalError:
	Extends Exception.
	This class represents a lexical error, and has a printMessage method
	which outputs to the console the line and error message recieved while 
	constructing the object by the IC.lex.
	
CLASS sym:
	Holds all Token ID's as integers.
	Generated automatically by IC.cup
	

CLASS Token:
	Implements the object Token. 
	It has 3 final private int fields: 
	(id) an integer representing its ID
	(value) a string representing its value
	(line) an integer which represents the number of line where
		the token appears in the IC file.
	the class contains getters for these 3 fields as well as the method
	toString() which returns a string which contains the information of the specific 
	Token.
	
CLASS Utils:
	Contains a simple function whose job is to recieve an integer and return it's 
	corresponding Token as set in class sym.
	
CLASS SyntaxError:
	Extends Exception,
	Contains 1 private field: token - contains the token that caused the error
	has 1 method which is responsible to output an error message containing the line
	where the error occured, and the token causing the error.
	
CLASS Parser:
	The parser which is generated by IC.cup
	
CLASS LibraryParser:
	The Library parser which is generated by Library.cup
								 
IC.AST
======
CLASS ASTNode:
	The class represents an AST node, 
	**notice we added there the function setLine which is used in order to set the line of a node.

CLASS ClassContents:
	A class we wrote in order to contain two lists:
		(1)A list of class fields.
		(2)A list of class methods.
	So, it is meant to contain as it name derives the class contents,
	accesing these fields (the two lists) is posible and setting them as well, essential in
	order to have the correct representation for a class with fields and methods.
							 
					CODE STRUCTURE
				  -----------------
The main work was on IC.cup, basicly we followed the grammar rules stated in the IC specifications,
we declared the terminals and non-terminals.
The reason that led us was looking at a program top-down, and that is the way we wrote the grammer

First, we have IC.lex which JFLEX is using in order to create Lexer.java which is responsible
to create a stream of tokens from a given IC program.
We also have IC.cup which Javacup uses to create parser.java, which defines a grammer for the 
IC language, and given a stream of tokens (recieved from Lexer) creates an AST tree 
representing the IC program. We also have Library.cup which Javacup uses to generate 
LibraryParser the parser which is used to parse library files.
Our code includes extending classes to Exception- LexicalError.java and SyntaxError.java, which
are used to handle lexical and syntactic errors.
Compiler.java is the class where the main is, where we use all the mentioned classes in order
to get a stream of tokens using the lexer, and then using the parser to create the corresponding
AST tree from that stream of tokens, an error is thrown if needed.


						TESTING STRATEGY
						-----------------

(1)We wrote some interesting IC files, with all sort of edge cases (each file represents different edge case)
   some are correct, meaning has no lexical error (maybe syntactic errors). Also worte these files expected output from the Compiler we wrote,
   and checked weather the expected and the actual are equal using a Junit testcase which assert the
   equality of each ic-out pair.

(2)We wrote some IC files, with all sort of edge cases some are correct, meaning has no syntactic error, and in 
   those files we checked all the correct grammar rules.
   We also wrote some files containing errors, and checked weather the bad sytax files really
   invoked the correct error message, and checked weather the good syntax ones caused the correct
   output-the correct AST tree.

							BUGS
							----
no bugs found.

				DESCRIPTION OF THE GRAMMAR
				---------------------------
based on the IC-specifications
		
		program ::= class_list
		
		class_list ::= class|
					   class_list class
		
		class ::= CLASS CLASS_ID EXTENDS CLASS_ID LCBR classcontents RCBR |
		 		  CLASS CLASS_ID LCBR classcontents RCBR | 
			      CLASS CLASS_ID EXTENDS CLASS_ID LCBR RCBR | 
			      CLASS CLASS_ID LCBR RCBR 
			
		classcontents ::= fields |
			              method | 
			              classcontents fields | 
			              classcontents method 
		
		fields ::= fieldsinrow SEMI 
		
		fieldsinrow ::= field|
				        fieldsinrow COMMA ID
			
		field ::= type ID
					 	 	 
		method ::=  STATIC type ID LP formals RP stmt_list|
					type ID LP formals RP stmt_list |
					STATIC type ID LP RP stmt_list |
					type ID LP RP stmt_list |
					STATIC VOID ID LP formals RP stmt_list |
					VOID ID LP formals RP stmt_list |
					STATIC VOID ID LP RP stmt_list |
					VOID ID LP RP stmt_list
		
		formal ::= type ID
		
		formals ::= formal |
					formals COMMA formal
						 
				
			
		type ::= INT | STRING | BOOLEAN | CLASS_ID |type
		
		expr ::=	
					expr PLUS expr |
					expr MINUS expr |
					expr MULTIPLY expr |
					expr DIVIDE expr  |
					expr MOD expr  |
					expr EQUAL expr  |
					expr NEQUAL expr |
					expr GT expr |
					expr GTE expr  |
					expr LT expr|
					expr LTE expr |
					expr LAND expr |
					expr LOR expr |
					LNEG expr |
					MINUS expr  %prec UMINUS |
					ID LP exprlist RP  |
					expr DOT LENGTH  |
					QUOTE |
					LP expr RP |
					NEW CLASS_ID LP RP  |
					NEW type LB expr RB  |
					location  | 
					call|
					THIS  |
					INTEGER |
					TRUE |
					FALSE  |
					NULL
		
		exprlist ::= expr| 
		 			exprlist COMMA expr
		
		
		stmt_list ::= statement|
					  stmt_list statement
		
		
		ifStatement ::= IF LP expr RP statement
		;
		elseStatement ::= ELSE statement
		;
		
		statement ::= 	ifStatement |
						ifStatement elseStatement |
						WHILE LP expr RP statement |
						BREAK SEMI  |
						CONTINUE SEMI  |
						RETURN expr SEMI  |
						RETURN SEMI |
						ID LP exprlist RP SEMI  |
						type ID ASSIGN expr SEMI  |
						type ID SEMI  |
						call SEMI |
						location ASSIGN expr SEMI   |
						LCBR stmt_list RCBR  |
						LCBR RCBR 
		
		
		location ::=	ID |
					  	expr DOT ID  |
					  	expr LB expr RB
		
		call ::= 	staticCall |
					virtualCall 
		
		staticCall ::= CLASS_ID DOT ID LP exprlist RP |
					   CLASS_ID DOT ID LP RP 
		
		virtualCall ::= expr DOT ID LP exprlist RP |
						ID LP actualParams RP |
						expr DOT ID LP RP |
						ID LP RP 
			  	
special choices you have made when creating the grammar
------------------------------------------------------
None, just according to the IC specification.
Special precedence options
--------------------------
We basically used the precedence and accosiativity according to the IC specification, but added two precedence terminals:
We gave ELSE precedence to resolve a shift/reduce conflict between IF and IF ELSE.
Without giving precedence to ELSE over IF the rule IF then ELSE would never be derived.
We also gave precedence to RCBR '}' to allow special cases such as an empty class or an empty statement block.
---------------------------
precedence left RCBR;
precedence left ELSE;
precedence right ASSIGN;
precedence left LOR;
precedence left LAND;
precedence left EQUAL, NEQUAL;
precedence left GTE, GT, LT, LTE;
precedence left MINUS, PLUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence right UMINUS, LNEG; 
precedence left DOT, LP, RP, LB, RB;









