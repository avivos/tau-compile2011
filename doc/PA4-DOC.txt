
         CLASS HIERARCHY
        -----------------
src:
	package IC:
		Compiler.java
		BinaryOps.java
		UnaryOps.java
		Utils.java
		DataTypes.java
		LiteralTypes.java
	
	package IC.AST:
	 		
	 	ASTNode.java
	 	ASTNode extending classes
	 	ClassContents.java
		
	package IC.lir
		ClassLayout.java
		LIRDispatchTable.java
		LirProgram.java
		LirTranslator.java
			
	package IC.lir.instruction
		the package containing classes which represent "Lir instruction" 
		as well as some ENUMS we used, e.g. BinaryInstructionEnum is for
		all possible binary operators.
			
	package IC.lir.parameter	
		the package contains all classes representing Lir objects, such as
		registers, memory, string.
		worth mentioning are field-pair and array-pair which represent any occurence of
		a pair in Lir code, e.g. R1[R2] or R1.R2
		we also implemented specific singletone classes for Rdummy and zeroImmediate. 
	
	package IC.Parser:
			
			Lexer.java
			LexicalError.java
			sym.java
			Token.java
			Utils.java
			IC.lex 
			SyntaxError.java
			IC.cup
			Parser.java
			sym.java 
			Library.cup
			LibraryParser.java
			
	
	package IC.SemanticChecks:
		
			BreakContinueChecker.java
			ReturnAllPathsCheck.java
			ScopeChecker.java
			SingleMainCheck.java
			ThisChecker.java
			TypeChecker.java
	
	package IC.SymbolTable:
			BlockSymbolTable.java
			ClassSymbolTable.java
			GlobalSymbolTable.java
			MethodSymbolTable.java
			SemanticError.java
			SemanticSymbol.java
			SymbolTable.java
			SymbolTableConstructor.java
	
	package IC.TYPE:
			ArrayType.java
			BoolType.java
			ClassType.java
			IntType.java
			Kind.java
			MethodType.java
			NullType.java
			StringType.java
			Type.java
			TypeTable.java
			TypeTableConstructor.java
			VoidType.java


DESCRIPTIONS OF MAJOR CLASSES
-----------------------------
IC
===
CLASS Compiler:
	The Compiler is the class where the main is.
	It recieves command line arguments and works accordingly.
	It parses the input .ic file according to the parser which is generated from IC.CUP.
	If needed it parses a .sig file.
	If requires it prints the output AST's by using the PrettyPrinter visitor. 

IC.Parser
=========
CLASS LexicalError:
	Extends Exception.
	This class represents a lexical error, and has a printMessage method
	which outputs to the console the line and error message recieved while 
	constructing the object by the IC.lex.
	
CLASS sym:
	Holds all Token ID's as integers.
	Generated automatically by IC.cup
	
CLASS Token:
	Implements the object Token. 
	It has 3 final private int fields: 
	(id) an integer representing its ID
	(value) a string representing its value
	(line) an integer which represents the number of line where
		the token appears in the IC file.
	the class contains getters for these 3 fields as well as the method
	toString() which returns a string which contains the information of the specific 
	Token.
	
CLASS Utils:
	Contains a simple function whose job is to recieve an integer and return it's 
	corresponding Token as set in class sym.
	
CLASS SyntaxError:
	Extends Exception,
	Contains 1 private field: token - contains the token that caused the error
	has 1 method which is responsible to output an error message containing the line
	where the error occured, and the token causing the error.
	
CLASS Parser:
	The parser which is generated by IC.cup
	
CLASS LibraryParser:
	The Library parser which is generated by Library.cup
								 
IC.AST
======
CLASS ASTNode:
	The class represents an AST node, 
	**notice we added there the function setLine which is used in order to set the line of a node.

CLASS ClassContents:
	A class we wrote in order to contain two lists:
		(1)A list of class fields.
		(2)A list of class methods.
	So, it is meant to contain as it name derives the class contents,
	accesing these fields (the two lists) is posible and setting them as well, essential in
	order to have the correct representation for a class with fields and methods.
			
IC.TYPE
======
CLASS TypeTable:
	This class holds all of the primitive types, and all of the unique array, methods and class types.
	This class represents a static type table of all types in the input program.
	
CLASS TypeTableConstructor:
	A class which is meant to build the type table through visiting the AST. Through this constructor
	we give some nodes their semantic type - (method, field & classes AST nodes).
	Basically the type table constructor traverses the AST and for each new type that it sees it adds that type to the program type table.

IC.SymbolTable
==============
CLASS SymbolTable
		    A class which is meant to represent the symbol table (and scope) of a certain entity (class,method etc.),
		    Later the structure of these symbol tables will represent the program structure.
		    This class holds the basic design of our symbol table. the main methods that are defined here
		    are: the insert method and the lookup methods.

CLASS BlockSymbolTable
CLASS ClassSymbolTable
CLASS GlobalSymbolTable
CLASS MethodSymbolTable
			All these classes are extending the class SymbolTable and are ment to have the required 
			features for each specific symbol table (class, method etc.)
			
CLASS SymbolTableConstructor
			Probably the component that does the most work in our program.
			It's job is to visit in all nodes of the AST and set semantic type for each node as well as setting an enclosing scope
			for each node meaning setting a symbol table where the search definition for the variable represented by that AST node 
			is commenced when needed.
			the parent-child relations between the symbol tables is also determined here. 
			
IC.SemanticChecks
=================

CLASS BreakContinueChecker
			A visitor that tries to find break/continue statement where it shold not been found,
			in case it finds one, it will report it to the main, where an error will be output.

CLASS ReturnAllPathsCheck
			A class that holds in it a static method which job is to see if there is any control path
			that does not return in a non-void method.
CLASS ScopeChecker
			A class that checks for redefenition for fields or methods in two classes where one extends the other,
			as mentioned later, the actual scope checking is actually done in the construction of the symbol table.
CLASS SingleMainCheck
			As the name implies this class contains a method that checks to see if the current program
			has less or more than a single main method of the correct signature.
CLASS ThisChecker
			Checks to see if there is a 'this' expression in a static method, which is illegal.
			done by a visitor.
CLASS TypeChecker
			As mentioned before most of the work is done in the SymbolTableConstructor, and so is the semantic type
			distribution for all AST nodes.
			In this class we check if there is any type mismatched assignment or any type mismatched
			false use of any variable.
			It is done by a visitor.
			
IC.lir
=============
CLASS ClassLayout
			This class represent the layout of an IC class,
			it contains two maps, the one for all fields, fiels name as key and it's offset
			as value.
			The other map does the same only for methods.
			We also take care of instances of inheritance, as we create a new classlayout for
			a new class but use the maps in the mother-class, overriding if needed, etc.
			
CLASS LIRDispatchTable
			For each classlayout in the program we create a dispatch-table,
			it is basically just a representation of the methods in the class, the Dispatch table.
			In this class we hold a list of LirLabels, and the name of the dispatch table itself,
			just so later in the Lir code we can have a convenient way of typing the DV.   
CLASS LirProgram
			Simply an "easy to translate to Lir" way of representing our IC program.
			Holds in it:
			(1) a list of strings, which are the string literals of the program. printed in the Lir code
			(2) a list of classlayouts
			(3) a list of Dispatch Vectors, printed later in the Lir code
			(4) a list of LirInstructions, the order they are inserted is the order when later they will be 
			    written into Lir code.
CLASS LirTranslator
			The visitor-class, the when that does all the messy work.
			We go over the AST, we commence at the root, the program ,where we create a new LirProgram object.
			We than go all over all classes and create the relevant classlayouts & dispatch tables, while taking under consideration
			relationships of inheritance.
			After that first part, we go and visit each class of the program, and so on we go deep into the AST.
			Throughout the visit in the AST we compose the Lir instructions needed to translate the AST into Lir code,
			
			for example, when visiting assignment we simply visit recursively the right side of the assignment and put the result into register,
			then we visit the left side, get the name of the variable (which also have a unique indetifier given to it in SemanticSymbol),
			we use this name to create a new LirMemory object, then we generate the correct move instruction involving the register holding 
			the result, and the memory we created. Slightly different actions took place in case of arrays, fields of locals or fields
			of class involved.
			
			whenever we visit a new string we add it to the stringLiteral list of the Lirprogram, and use that LirString label in the instruction we compose.


--------------------------------------------------------------------------------------------------
							 
					CODE STRUCTURE
				  -----------------
First, we have IC.lex which JFLEX is using in order to create Lexer.java which is responsible
to create a stream of tokens from a given IC program.
We also have IC.cup which Javacup uses to create parser.java, which defines a grammer for the 
IC language, and given a stream of tokens (recieved from Lexer) creates an AST tree 
representing the IC program. We also have Library.cup which Javacup uses to generate 
LibraryParser the parser which is used to parse library files.
Our code includes extending classes to Exception- LexicalError.java and SyntaxError.java, which
are used to handle lexical and syntactic errors.
Compiler.java is the class where the main is, where we use all the mentioned classes in order
to get a stream of tokens using the lexer, and then using the parser to create the corresponding
AST tree from that stream of tokens, an error is thrown if needed.

Next the main work was on IC.cup, basically we followed the grammar rules stated in the IC specifications,
we declared the terminals and non-terminals.
The reason that led us was looking at a program top-down, and that is the way we wrote the grammer
						
The third step then, is the semantic analysis,
done by these following steps:
(1) If given a library class we attach it to the given IC program AST.
(2) we use the TypeTableConstructor to visit the IC program and give semantic types to some of it's nodes (classes, fields,methods) 
	and fill the symbol table of the classes with the corresponding fields and methods.
	(the methods are yet to be visited and assigned a symbol table of their own).
(3) we next use the SymbolTableConstructor, here through visiting the whole AST we assign an enclosing scope for each node,
	we set a semantic type for each node through finding it's definition in it's enclosing scope(or if not found there on the following
	enclosing scope- simply the symbol table that is the father of the current symbol table)
	basically if no such definition is found we need to report an error to the user, unless it is defined later on the code, we 
	decided to deal with these scenario by adding an undefined object to a global list named "forwardrefs"
	after the first basic iteration on the AST, we go through forwardrefs to see if we can find them now
	if any of them is not found we report an error for an undefinition. 
(4) next, we do the rest of the semantic checks that are described above:
	- a class heirarchy check.
	-the scopecheck
	-the break/continue check
	-this check
	-main chack
	-type check
	-return from all paths check
	
passing all these checks means that the program is valid,
and so the next step will be to print out the types in the program, and the symbol tables themselves
as well as the AST if needed (which is now updated with enclosing scope and semantic type for each node).

(--from here relevant to current assignment--)
fourth step is the IR representation.
Part of our treatment to the AST in this part is already depicted in the LirTranslator visitor explanation, as it is the class
that generate the Lir-code.
We explained about all the objects we use throughout the translation, and so, as mentioned before we first prepare the classlayouts & DV's,
afterwards we go all over the ast in order to generate the instructions, through each node visited we composed the relevant instructions, 
dependent of course on the visit of it's sons.
interesting points:
	- we use the LirREG object, which is responsible to supply the LIRtranslator with a free Rx register, and the translator is responsible
	  to free unused registers, which basically means setting them as unused.
	- we keep global variable of FieldPair object, we do this because we always want to know what is the last pair we visited, it serves us when
	  treating "deep" locations, (e.g. a.b.c.d.num)
      we keep a global ArrayPair object for the same reasons.
    - we keep a global Strings recentLoopLabel & recentEndLabel which help us know all the time to which label we ought to jump in case of
      continue or break accordingly.
    - we added a unique ID to every SemanticSymbol created, more precisely each scoped-variable has it's different ID, we had to add this feature
      in order to prevent shadowing. 
   			
						TESTING STRATEGY
						-----------------
(2)We tried our program on some IC files, which has different possible forms.
   for example, we checked that all the compare operations work as expected, we also checked that the binary and unary
   operations work as expected.
   we tried different programs containing different sets of while statements, also to test the correctness of continue/break translations.
   and more.
   clearly enough we ran our Lir code with the MicroLir given to us and compared the output to the expected. 

							BUGS
							----
no known bugs found.

					IR LOWERING DESCRIPTION
					-----------------------
	In High-level view we translate all of the IC program using the AST and the information 
	gathered during the semantic analysis before. If -L is stated we also read the Library parses it, and add it to the AST. 
	The compiler takes under consideration inheritance relationships, when analyzing the IC program, which is important for keeping 
	information to every class explained next. 
	For each class of the IC program the compiler holds information, this information tells us later about the offset of each
	field or virtual method in that class (helps us build the DV and is also used for MOVEFIELD instructions). 
	As mentioned before in this document we use a visitor in order to go through the AST ant translate the AST into Lir code,
	by using the visitor we break the translation action into small bits, each visit (or more correctly, some of them) causes Lir instruction 
	emiting, which is kept in a data structure of Lir instructions. All together, these instructions compose the instructions in the Lir code.
	All of this work by the compiler is done mainly by using objects that represent the Lir operands (register,immediate,memory etc.) and instructions (call, jump, move, etc.).   
------------------------------------




