note:
We have implemented one of the bonus checks - the "return from all paths" check.

         CLASS HIERARCHY
        -----------------
src:
	package IC:
		Compiler.java
		BinaryOps.java
		UnaryOps.java
		Utils.java
		DataTypes.java
		LiteralTypes.java
	
	package IC.AST:
	 		
	 		ASTNode.java
	 		ASTNode extending classes
	 		ClassContents.java
			
	package IC.Parser:
			
			Lexer.java
			LexicalError.java
			sym.java
			Token.java
			Utils.java
			IC.lex 
			SyntaxError.java
			IC.cup
			Parser.java
			sym.java 
			Library.cup
			LibraryParser.java
			
	
	package IC.SemanticChecks:
		
			BreakContinueChecker.java
			ReturnAllPathsCheck.java
			ScopeChecker.java
			SingleMainCheck.java
			ThisChecker.java
			TypeChecker.java
	
	package IC.SymbolTable:
			BlockSymbolTable.java
			ClassSymbolTable.java
			GlobalSymbolTable.java
			MethodSymbolTable.java
			SemanticError.java
			SemanticSymbol.java
			SymbolTable.java
			SymbolTableConstructor.java
	
	package IC.TYPE:
			ArrayType.java
			BoolType.java
			ClassType.java
			IntType.java
			Kind.java
			MethodType.java
			NullType.java
			StringType.java
			Type.java
			TypeTable.java
			TypeTableConstructor.java
			VoidType.java


DESCRIPTIONS OF MAJOR CLASSES
-----------------------------
IC
===
CLASS Compiler:
	The Compiler is the class where the main is.
	It recieves command line arguments and works accordingly.
	It parses the input .ic file according to the parser which is generated from IC.CUP.
	If needed it parses a .sig file.
	If requires it prints the output AST's by using the PrettyPrinter visitor. 

IC.Parser
=========
CLASS LexicalError:
	Extends Exception.
	This class represents a lexical error, and has a printMessage method
	which outputs to the console the line and error message recieved while 
	constructing the object by the IC.lex.
	
CLASS sym:
	Holds all Token ID's as integers.
	Generated automatically by IC.cup
	
CLASS Token:
	Implements the object Token. 
	It has 3 final private int fields: 
	(id) an integer representing its ID
	(value) a string representing its value
	(line) an integer which represents the number of line where
		the token appears in the IC file.
	the class contains getters for these 3 fields as well as the method
	toString() which returns a string which contains the information of the specific 
	Token.
	
CLASS Utils:
	Contains a simple function whose job is to recieve an integer and return it's 
	corresponding Token as set in class sym.
	
CLASS SyntaxError:
	Extends Exception,
	Contains 1 private field: token - contains the token that caused the error
	has 1 method which is responsible to output an error message containing the line
	where the error occured, and the token causing the error.
	
CLASS Parser:
	The parser which is generated by IC.cup
	
CLASS LibraryParser:
	The Library parser which is generated by Library.cup
								 
IC.AST
======
CLASS ASTNode:
	The class represents an AST node, 
	**notice we added there the function setLine which is used in order to set the line of a node.

CLASS ClassContents:
	A class we wrote in order to contain two lists:
		(1)A list of class fields.
		(2)A list of class methods.
	So, it is meant to contain as it name derives the class contents,
	accesing these fields (the two lists) is posible and setting them as well, essential in
	order to have the correct representation for a class with fields and methods.
			
IC.TYPE
======
CLASS TypeTable:
	This class holds all of the primitive types, and all of the unique array, methods and class types.
	This class represents a static type table of all types in the input program.
	
CLASS TypeTableConstructor:
	A class which is meant to build the type table through visiting the AST. Through this constructor
	we give some nodes their semantic type - (method, field & classes AST nodes).
	Basically the type table constructor traverses the AST and for each new type that it sees it adds that type to the program type table.

IC.SymbolTable
==============
CLASS SymbolTable
		    A class which is meant to represent the symbol table (and scope) of a certain entity (class,method etc.),
		    Later the structure of these symbol tables will represent the program structure.
		    This class holds the basic design of our symbol table. the main methods that are defined here
		    are: the insert method and the lookup methods.

CLASS BlockSymbolTable
CLASS ClassSymbolTable
CLASS GlobalSymbolTable
CLASS MethodSymbolTable
			All these classes are extending the class SymbolTable and are ment to have the required 
			features for each specific symbol table (class, method etc.)
			
CLASS SymbolTableConstructor
			Probably the component that does the most work in our program.
			It's job is to visit in all nodes of the AST and set semantic type for each node as well as setting an enclosing scope
			for each node meaning setting a symbol table where the search definition for the variable represented by that AST node 
			is commenced when needed.
			the parent-child relations between the symbol tables is also determined here. 
			
IC.SemanticChecks
=================

CLASS BreakContinueChecker
			A visitor that tries to find break/continue statement where it shold not been found,
			in case it finds one, it will report it to the main, where an error will be output.

CLASS ReturnAllPathsCheck
			A class that holds in it a static method which job is to see if there is any control path
			that does not return in a non-void method.
CLASS ScopeChecker
			A class that checks for redefenition for fields or methods in two classes where one extends the other,
			as mentioned later, the actual scope checking is actually done in the construction of the symbol table.
CLASS SingleMainCheck
			As the name implies this class contains a method that checks to see if the current program
			has less or more than a single main method of the correct signature.
CLASS ThisChecker
			Checks to see if there is a 'this' expression in a static method, which is illegal.
			done by a visitor.
CLASS TypeChecker
			As mentioned before most of the work is done in the SymbolTableConstructor, and so is the semantic type
			distribution for all AST nodes.
			In this class we check if there is any type mismatched assignment or any type mismatched
			false use of any variable.
			It is done by a visitor.
--------------------------------------------------------------------------------------------------
							 
					CODE STRUCTURE
				  -----------------
First, we have IC.lex which JFLEX is using in order to create Lexer.java which is responsible
to create a stream of tokens from a given IC program.
We also have IC.cup which Javacup uses to create parser.java, which defines a grammer for the 
IC language, and given a stream of tokens (recieved from Lexer) creates an AST tree 
representing the IC program. We also have Library.cup which Javacup uses to generate 
LibraryParser the parser which is used to parse library files.
Our code includes extending classes to Exception- LexicalError.java and SyntaxError.java, which
are used to handle lexical and syntactic errors.
Compiler.java is the class where the main is, where we use all the mentioned classes in order
to get a stream of tokens using the lexer, and then using the parser to create the corresponding
AST tree from that stream of tokens, an error is thrown if needed.

Next the main work was on IC.cup, basically we followed the grammar rules stated in the IC specifications,
we declared the terminals and non-terminals.
The reason that led us was looking at a program top-down, and that is the way we wrote the grammer
						
(--from here relevant to current assignment--)
The third step then, is the semantic analysis,
done by these following steps:
(1) If given a library class we attach it to the given IC program AST.
(2) we use the TypeTableConstructor to visit the IC program and give semantic types to some of it's nodes (classes, fields,methods) 
	and fill the symbol table of the classes with the corresponding fields and methods.
	(the methods are yet to be visited and assigned a symbol table of their own).
(3) we next use the SymbolTableConstructor, here through visiting the whole AST we assign an enclosing scope for each node,
	we set a semantic type for each node through finding it's definition in it's enclosing scope(or if not found there on the following
	enclosing scope- simply the symbol table that is the father of the current symbol table)
	basically if no such definition is found we need to report an error to the user, unless it is defined later on the code, we 
	decided to deal with these scenario by adding an undefined object to a global list named "forwardrefs"
	after the first basic iteration on the AST, we go through forwardrefs to see if we can find them now
	if any of them is not found we report an error for an undefinition. 
(4) next, we do the rest of the semantic checks that are described above:
	- a class heirarchy check.
	-the scopecheck
	-the break/continue check
	-this check
	-main chack
	-type check
	-return from all paths check
	
passing all these checks means that the program is valid,
and so the next step will be to print out the types in the program, and the symbol tables themselves
as well as the AST if needed (which is now updated with enclosing scope and semantic type for each node).

							
						TESTING STRATEGY
						-----------------
(2)We tried our program on some IC files, with all sort of edge cases some are correct, meaning has no errors,
   In these cases we checked if the output is accurate.
   We also wrote some files containing semantic errors, and checked weather these files really
   invoked the correct error message.
   The cases we checked were extensive checking each possible expression and statement (we think:))

							BUGS
							----
no known bugs found.


